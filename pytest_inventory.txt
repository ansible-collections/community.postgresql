============================= test session starts ==============================
platform linux -- Python 3.13.5, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/gebz/projects/ansible/collections/ansible_collections/community.postgresql
plugins: mock-3.15.1
collected 26 items

tests/unit/plugins/inventory/test_postgresql_inventory.py ....FFF.F..... [ 53%]
.F.....FF..F                                                             [100%]

=================================== FAILURES ===================================
_______ TestPostgreSQLInventoryPlugin.test_get_connection_missing_params _______

self = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)
option = 'db_port', hostvars = None

    def get_option_and_origin(self, option, hostvars=None):
        if option not in self._options:
            try:
                # some plugins don't use set_option(s) and cannot use direct settings, so this populates the local copy for them
>               self._options[option], self._origins[option] = C.config.get_config_value_and_origin(option, plugin_type=self.plugin_type,
                                                                                                    plugin_name=self._load_name, variables=hostvars)

../../../../python/venv/lib/python3.13/site-packages/ansible/plugins/__init__.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ansible.config.manager.ConfigManager object at 0x7f2a0b58dd30>
config = 'db_port', cfile = None, plugin_type = 'inventory', plugin_name = None
keys = None, variables = None, direct = None

    def get_config_value_and_origin(self, config, cfile=None, plugin_type=None, plugin_name=None, keys=None, variables=None, direct=None):
        """ Given a config key figure out the actual value and report on the origin of the settings """
        if cfile is None:
            # use default config
            cfile = self._config_file
    
        if config == 'CONFIG_FILE':
            return cfile, ''
    
        # Note: sources that are lists listed in low to high precedence (last one wins)
        value = None
        origin = None
        origin_ftype = None
    
        defs = self.get_configuration_definitions(plugin_type=plugin_type, name=plugin_name)
        if config in defs:
    
            aliases = defs[config].get('aliases', [])
    
            # direct setting via plugin arguments, can set to None so we bypass rest of processing/defaults
            if direct:
                if config in direct:
                    value = direct[config]
                    origin = 'Direct'
                else:
                    direct_aliases = [direct[alias] for alias in aliases if alias in direct]
                    if direct_aliases:
                        value = direct_aliases[0]
                        origin = 'Direct'
    
            if value is None and variables and defs[config].get('vars'):
                # Use 'variable overrides' if present, highest precedence, but only present when querying running play
                value, origin = self._loop_entries(variables, defs[config]['vars'])
                origin = 'var: %s' % origin
    
            # use playbook keywords if you have em
            if value is None and defs[config].get('keyword') and keys:
                value, origin = self._loop_entries(keys, defs[config]['keyword'])
                origin = 'keyword: %s' % origin
    
            # automap to keywords
            # TODO: deprecate these in favor of explicit keyword above
            if value is None and keys:
                if config in keys:
                    value = keys[config]
                    keyword = config
    
                elif aliases:
                    for alias in aliases:
                        if alias in keys:
                            value = keys[alias]
                            keyword = alias
                            break
    
                if value is not None:
                    origin = 'keyword: %s' % keyword
    
            if value is None and 'cli' in defs[config]:
                # avoid circular import .. until valid
                from ansible import context
                value, origin = self._loop_entries(context.CLIARGS, defs[config]['cli'])
                origin = 'cli: %s' % origin
    
            # env vars are next precedence
            if value is None and defs[config].get('env'):
                value, origin = self._loop_entries(os.environ, defs[config]['env'])
                value = _tags.TrustedAsTemplate().tag(value)
                origin = 'env: %s' % origin
    
            # try config file entries next, if we have one
            if self._parsers.get(cfile, None) is None:
                self._parse_config_file(cfile)
    
            # attempt to read from config file
            if value is None and cfile is not None:
                ftype = get_config_type(cfile)
                if ftype and defs[config].get(ftype):
                    try:
                        for entry in defs[config][ftype]:
                            # load from config
                            if ftype == 'ini':
                                temp_value = self._get_ini_config_value(cfile, entry.get('section', 'defaults'), entry['key'])
                            elif ftype == 'yaml':
                                raise AnsibleError('YAML configuration type has not been implemented yet')
                            else:
                                raise AnsibleError('Invalid configuration file type: %s' % ftype)
    
                            if temp_value is not None:
                                # set value and origin
                                value = temp_value
                                origin = cfile
                                origin_ftype = ftype
                                if 'deprecated' in entry:
                                    if ftype == 'ini':
                                        self.DEPRECATED.append(('[%s]%s' % (entry['section'], entry['key']), entry['deprecated']))
                                    else:
                                        raise AnsibleError('Unimplemented file type: %s' % ftype)
    
                    except Exception as e:
                        sys.stderr.write("Error while loading config %s: %s" % (cfile, to_native(e)))
    
            # set default if we got here w/o a value
            if value is None:
                if defs[config].get('required', False):
                    if not plugin_type or config not in INTERNAL_DEFS.get(plugin_type, {}):
                        raise AnsibleRequiredOptionError(f"Required config {_get_config_label(plugin_type, plugin_name, config)} not provided.")
                else:
                    origin = 'default'
                    value = self.template_default(defs[config].get('default'), variables, key_name=_get_config_label(plugin_type, plugin_name, config))
    
            try:
                # ensure correct type, can raise exceptions on mismatched types
                value = ensure_type(value, defs[config].get('type'), origin=origin, origin_ftype=origin_ftype)
            except ValueError as ex:
                if origin.startswith('env:') and value == '':
                    # this is empty env var for non string so we can set to default
                    origin = 'default'
                    value = ensure_type(defs[config].get('default'), defs[config].get('type'), origin=origin, origin_ftype=origin_ftype)
                else:
                    raise AnsibleOptionsError(f'Config {_get_config_label(plugin_type, plugin_name, config)} from {origin!r} has an invalid value.') from ex
    
            # deal with restricted values
            if value is not None and 'choices' in defs[config] and defs[config]['choices'] is not None:
                invalid_choices = True  # assume the worst!
                if defs[config].get('type') == 'list':
                    # for a list type, compare all values in type are allowed
                    invalid_choices = not all(choice in defs[config]['choices'] for choice in value)
                else:
                    # these should be only the simple data types (string, int, bool, float, etc) .. ignore dicts for now
                    invalid_choices = value not in defs[config]['choices']
    
                if invalid_choices:
    
                    if isinstance(defs[config]['choices'], Mapping):
                        valid = ', '.join([to_text(k) for k in defs[config]['choices'].keys()])
                    elif isinstance(defs[config]['choices'], str):
                        valid = defs[config]['choices']
                    elif isinstance(defs[config]['choices'], Sequence):
                        valid = ', '.join([to_text(c) for c in defs[config]['choices']])
                    else:
                        valid = defs[config]['choices']
    
                    raise AnsibleOptionsError(f'Invalid value {value!r} for config {_get_config_label(plugin_type, plugin_name, config)}.',
                                              help_text=f'Valid values are: {valid}')
    
            # deal with deprecation of the setting
            if 'deprecated' in defs[config] and origin != 'default':
                self.DEPRECATED.append((config, defs[config].get('deprecated')))
        else:
>           raise AnsibleUndefinedConfigEntry(f'No config definition exists for {_get_config_label(plugin_type, plugin_name, config)}.')
E           ansible.errors.AnsibleUndefinedConfigEntry: No config definition exists for 'db_port' for inventory plugin.

../../../../python/venv/lib/python3.13/site-packages/ansible/config/manager.py:708: AnsibleUndefinedConfigEntry

The above exception was the direct cause of the following exception:

self = <test_postgresql_inventory.TestPostgreSQLInventoryPlugin object at 0x7f2a0a185eb0>
inventory_plugin = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)

    def test_get_connection_missing_params(self, inventory_plugin):
        """Test connection fails when required parameters are missing."""
        inventory_plugin.set_options(direct={
            'plugin': 'community.postgresql.postgresql_inventory',
            'db_host': 'localhost'
            # Missing db_name, db_user, db_password
        })
    
        with pytest.raises(AnsibleParserError):
>           inventory_plugin._get_connection()

tests/unit/plugins/inventory/test_postgresql_inventory.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
plugins/inventory/postgresql_inventory.py:154: in _get_connection
    db_port = self.get_option("db_port")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../python/venv/lib/python3.13/site-packages/ansible/plugins/__init__.py:124: in get_option
    self.get_option_and_origin(option, hostvars=hostvars)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)
option = 'db_port', hostvars = None

    def get_option_and_origin(self, option, hostvars=None):
        if option not in self._options:
            try:
                # some plugins don't use set_option(s) and cannot use direct settings, so this populates the local copy for them
                self._options[option], self._origins[option] = C.config.get_config_value_and_origin(option, plugin_type=self.plugin_type,
                                                                                                    plugin_name=self._load_name, variables=hostvars)
            except AnsibleError as e:
                # callers expect key error on missing
>               raise KeyError() from e
E               KeyError

../../../../python/venv/lib/python3.13/site-packages/ansible/plugins/__init__.py:109: KeyError
_________ TestPostgreSQLInventoryPlugin.test_execute_query_with_cache __________

self = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)
option = 'db_host', hostvars = None

    def get_option_and_origin(self, option, hostvars=None):
        if option not in self._options:
            try:
                # some plugins don't use set_option(s) and cannot use direct settings, so this populates the local copy for them
>               self._options[option], self._origins[option] = C.config.get_config_value_and_origin(option, plugin_type=self.plugin_type,
                                                                                                    plugin_name=self._load_name, variables=hostvars)

../../../../python/venv/lib/python3.13/site-packages/ansible/plugins/__init__.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ansible.config.manager.ConfigManager object at 0x7f2a0b58dd30>
config = 'db_host', cfile = None, plugin_type = 'inventory', plugin_name = None
keys = None, variables = None, direct = None

    def get_config_value_and_origin(self, config, cfile=None, plugin_type=None, plugin_name=None, keys=None, variables=None, direct=None):
        """ Given a config key figure out the actual value and report on the origin of the settings """
        if cfile is None:
            # use default config
            cfile = self._config_file
    
        if config == 'CONFIG_FILE':
            return cfile, ''
    
        # Note: sources that are lists listed in low to high precedence (last one wins)
        value = None
        origin = None
        origin_ftype = None
    
        defs = self.get_configuration_definitions(plugin_type=plugin_type, name=plugin_name)
        if config in defs:
    
            aliases = defs[config].get('aliases', [])
    
            # direct setting via plugin arguments, can set to None so we bypass rest of processing/defaults
            if direct:
                if config in direct:
                    value = direct[config]
                    origin = 'Direct'
                else:
                    direct_aliases = [direct[alias] for alias in aliases if alias in direct]
                    if direct_aliases:
                        value = direct_aliases[0]
                        origin = 'Direct'
    
            if value is None and variables and defs[config].get('vars'):
                # Use 'variable overrides' if present, highest precedence, but only present when querying running play
                value, origin = self._loop_entries(variables, defs[config]['vars'])
                origin = 'var: %s' % origin
    
            # use playbook keywords if you have em
            if value is None and defs[config].get('keyword') and keys:
                value, origin = self._loop_entries(keys, defs[config]['keyword'])
                origin = 'keyword: %s' % origin
    
            # automap to keywords
            # TODO: deprecate these in favor of explicit keyword above
            if value is None and keys:
                if config in keys:
                    value = keys[config]
                    keyword = config
    
                elif aliases:
                    for alias in aliases:
                        if alias in keys:
                            value = keys[alias]
                            keyword = alias
                            break
    
                if value is not None:
                    origin = 'keyword: %s' % keyword
    
            if value is None and 'cli' in defs[config]:
                # avoid circular import .. until valid
                from ansible import context
                value, origin = self._loop_entries(context.CLIARGS, defs[config]['cli'])
                origin = 'cli: %s' % origin
    
            # env vars are next precedence
            if value is None and defs[config].get('env'):
                value, origin = self._loop_entries(os.environ, defs[config]['env'])
                value = _tags.TrustedAsTemplate().tag(value)
                origin = 'env: %s' % origin
    
            # try config file entries next, if we have one
            if self._parsers.get(cfile, None) is None:
                self._parse_config_file(cfile)
    
            # attempt to read from config file
            if value is None and cfile is not None:
                ftype = get_config_type(cfile)
                if ftype and defs[config].get(ftype):
                    try:
                        for entry in defs[config][ftype]:
                            # load from config
                            if ftype == 'ini':
                                temp_value = self._get_ini_config_value(cfile, entry.get('section', 'defaults'), entry['key'])
                            elif ftype == 'yaml':
                                raise AnsibleError('YAML configuration type has not been implemented yet')
                            else:
                                raise AnsibleError('Invalid configuration file type: %s' % ftype)
    
                            if temp_value is not None:
                                # set value and origin
                                value = temp_value
                                origin = cfile
                                origin_ftype = ftype
                                if 'deprecated' in entry:
                                    if ftype == 'ini':
                                        self.DEPRECATED.append(('[%s]%s' % (entry['section'], entry['key']), entry['deprecated']))
                                    else:
                                        raise AnsibleError('Unimplemented file type: %s' % ftype)
    
                    except Exception as e:
                        sys.stderr.write("Error while loading config %s: %s" % (cfile, to_native(e)))
    
            # set default if we got here w/o a value
            if value is None:
                if defs[config].get('required', False):
                    if not plugin_type or config not in INTERNAL_DEFS.get(plugin_type, {}):
                        raise AnsibleRequiredOptionError(f"Required config {_get_config_label(plugin_type, plugin_name, config)} not provided.")
                else:
                    origin = 'default'
                    value = self.template_default(defs[config].get('default'), variables, key_name=_get_config_label(plugin_type, plugin_name, config))
    
            try:
                # ensure correct type, can raise exceptions on mismatched types
                value = ensure_type(value, defs[config].get('type'), origin=origin, origin_ftype=origin_ftype)
            except ValueError as ex:
                if origin.startswith('env:') and value == '':
                    # this is empty env var for non string so we can set to default
                    origin = 'default'
                    value = ensure_type(defs[config].get('default'), defs[config].get('type'), origin=origin, origin_ftype=origin_ftype)
                else:
                    raise AnsibleOptionsError(f'Config {_get_config_label(plugin_type, plugin_name, config)} from {origin!r} has an invalid value.') from ex
    
            # deal with restricted values
            if value is not None and 'choices' in defs[config] and defs[config]['choices'] is not None:
                invalid_choices = True  # assume the worst!
                if defs[config].get('type') == 'list':
                    # for a list type, compare all values in type are allowed
                    invalid_choices = not all(choice in defs[config]['choices'] for choice in value)
                else:
                    # these should be only the simple data types (string, int, bool, float, etc) .. ignore dicts for now
                    invalid_choices = value not in defs[config]['choices']
    
                if invalid_choices:
    
                    if isinstance(defs[config]['choices'], Mapping):
                        valid = ', '.join([to_text(k) for k in defs[config]['choices'].keys()])
                    elif isinstance(defs[config]['choices'], str):
                        valid = defs[config]['choices']
                    elif isinstance(defs[config]['choices'], Sequence):
                        valid = ', '.join([to_text(c) for c in defs[config]['choices']])
                    else:
                        valid = defs[config]['choices']
    
                    raise AnsibleOptionsError(f'Invalid value {value!r} for config {_get_config_label(plugin_type, plugin_name, config)}.',
                                              help_text=f'Valid values are: {valid}')
    
            # deal with deprecation of the setting
            if 'deprecated' in defs[config] and origin != 'default':
                self.DEPRECATED.append((config, defs[config].get('deprecated')))
        else:
>           raise AnsibleUndefinedConfigEntry(f'No config definition exists for {_get_config_label(plugin_type, plugin_name, config)}.')
E           ansible.errors.AnsibleUndefinedConfigEntry: No config definition exists for 'db_host' for inventory plugin.

../../../../python/venv/lib/python3.13/site-packages/ansible/config/manager.py:708: AnsibleUndefinedConfigEntry

The above exception was the direct cause of the following exception:

self = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)
query = 'SELECT * FROM hosts', cache_key = 'test_key'

    def _execute_query(self, query, cache_key=None):
        """Execute a SQL query and return results, with optional caching."""
        if cache_key and self.get_option("cache"):
            cached_data = self._get_cache_data(cache_key)
            if cached_data is not None:
                return cached_data
    
        try:
>           with self._get_connection() as conn:
                 ^^^^^^^^^^^^^^^^^^^^^^

plugins/inventory/postgresql_inventory.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
plugins/inventory/postgresql_inventory.py:153: in _get_connection
    db_host = self.get_option("db_host")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../python/venv/lib/python3.13/site-packages/ansible/plugins/__init__.py:124: in get_option
    self.get_option_and_origin(option, hostvars=hostvars)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)
option = 'db_host', hostvars = None

    def get_option_and_origin(self, option, hostvars=None):
        if option not in self._options:
            try:
                # some plugins don't use set_option(s) and cannot use direct settings, so this populates the local copy for them
                self._options[option], self._origins[option] = C.config.get_config_value_and_origin(option, plugin_type=self.plugin_type,
                                                                                                    plugin_name=self._load_name, variables=hostvars)
            except AnsibleError as e:
                # callers expect key error on missing
>               raise KeyError() from e
E               KeyError

../../../../python/venv/lib/python3.13/site-packages/ansible/plugins/__init__.py:109: KeyError

During handling of the above exception, another exception occurred:

self = <test_postgresql_inventory.TestPostgreSQLInventoryPlugin object at 0x7f2a0a11e690>
inventory_plugin = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)
mock_connection = (<MagicMock name='connect' id='139818534818144'>, <MagicMock name='connect().__enter__().cursor().__enter__()' id='139818534817136'>)

    def test_execute_query_with_cache(self, inventory_plugin, mock_connection):
        """Test query execution with caching enabled."""
        mock_conn, mock_cursor = mock_connection
        mock_cursor.fetchall.return_value = [('host1', ['group1'])]
    
        inventory_plugin.set_options({
            'plugin': 'community.postgresql.postgresql_inventory',
            'cache': True
        })
    
        # First call - should execute query
>       result = inventory_plugin._execute_query('SELECT * FROM hosts', 'test_key')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/plugins/inventory/test_postgresql_inventory.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)
query = 'SELECT * FROM hosts', cache_key = 'test_key'

    def _execute_query(self, query, cache_key=None):
        """Execute a SQL query and return results, with optional caching."""
        if cache_key and self.get_option("cache"):
            cached_data = self._get_cache_data(cache_key)
            if cached_data is not None:
                return cached_data
    
        try:
            with self._get_connection() as conn:
                with conn.cursor() as cur:
                    cur.execute(query)
                    result = cur.fetchall()
    
                    if cache_key and self.get_option("cache"):
                        self._set_cache_data(cache_key, result)
    
                    return result
        except Exception as e:
>           raise AnsibleError(f"Database query failed: {e}")
E           ansible.errors.AnsibleError: Database query failed:

plugins/inventory/postgresql_inventory.py:190: AnsibleError
________ TestPostgreSQLInventoryPlugin.test_execute_query_without_cache ________

self = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)
option = 'db_host', hostvars = None

    def get_option_and_origin(self, option, hostvars=None):
        if option not in self._options:
            try:
                # some plugins don't use set_option(s) and cannot use direct settings, so this populates the local copy for them
>               self._options[option], self._origins[option] = C.config.get_config_value_and_origin(option, plugin_type=self.plugin_type,
                                                                                                    plugin_name=self._load_name, variables=hostvars)

../../../../python/venv/lib/python3.13/site-packages/ansible/plugins/__init__.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ansible.config.manager.ConfigManager object at 0x7f2a0b58dd30>
config = 'db_host', cfile = None, plugin_type = 'inventory', plugin_name = None
keys = None, variables = None, direct = None

    def get_config_value_and_origin(self, config, cfile=None, plugin_type=None, plugin_name=None, keys=None, variables=None, direct=None):
        """ Given a config key figure out the actual value and report on the origin of the settings """
        if cfile is None:
            # use default config
            cfile = self._config_file
    
        if config == 'CONFIG_FILE':
            return cfile, ''
    
        # Note: sources that are lists listed in low to high precedence (last one wins)
        value = None
        origin = None
        origin_ftype = None
    
        defs = self.get_configuration_definitions(plugin_type=plugin_type, name=plugin_name)
        if config in defs:
    
            aliases = defs[config].get('aliases', [])
    
            # direct setting via plugin arguments, can set to None so we bypass rest of processing/defaults
            if direct:
                if config in direct:
                    value = direct[config]
                    origin = 'Direct'
                else:
                    direct_aliases = [direct[alias] for alias in aliases if alias in direct]
                    if direct_aliases:
                        value = direct_aliases[0]
                        origin = 'Direct'
    
            if value is None and variables and defs[config].get('vars'):
                # Use 'variable overrides' if present, highest precedence, but only present when querying running play
                value, origin = self._loop_entries(variables, defs[config]['vars'])
                origin = 'var: %s' % origin
    
            # use playbook keywords if you have em
            if value is None and defs[config].get('keyword') and keys:
                value, origin = self._loop_entries(keys, defs[config]['keyword'])
                origin = 'keyword: %s' % origin
    
            # automap to keywords
            # TODO: deprecate these in favor of explicit keyword above
            if value is None and keys:
                if config in keys:
                    value = keys[config]
                    keyword = config
    
                elif aliases:
                    for alias in aliases:
                        if alias in keys:
                            value = keys[alias]
                            keyword = alias
                            break
    
                if value is not None:
                    origin = 'keyword: %s' % keyword
    
            if value is None and 'cli' in defs[config]:
                # avoid circular import .. until valid
                from ansible import context
                value, origin = self._loop_entries(context.CLIARGS, defs[config]['cli'])
                origin = 'cli: %s' % origin
    
            # env vars are next precedence
            if value is None and defs[config].get('env'):
                value, origin = self._loop_entries(os.environ, defs[config]['env'])
                value = _tags.TrustedAsTemplate().tag(value)
                origin = 'env: %s' % origin
    
            # try config file entries next, if we have one
            if self._parsers.get(cfile, None) is None:
                self._parse_config_file(cfile)
    
            # attempt to read from config file
            if value is None and cfile is not None:
                ftype = get_config_type(cfile)
                if ftype and defs[config].get(ftype):
                    try:
                        for entry in defs[config][ftype]:
                            # load from config
                            if ftype == 'ini':
                                temp_value = self._get_ini_config_value(cfile, entry.get('section', 'defaults'), entry['key'])
                            elif ftype == 'yaml':
                                raise AnsibleError('YAML configuration type has not been implemented yet')
                            else:
                                raise AnsibleError('Invalid configuration file type: %s' % ftype)
    
                            if temp_value is not None:
                                # set value and origin
                                value = temp_value
                                origin = cfile
                                origin_ftype = ftype
                                if 'deprecated' in entry:
                                    if ftype == 'ini':
                                        self.DEPRECATED.append(('[%s]%s' % (entry['section'], entry['key']), entry['deprecated']))
                                    else:
                                        raise AnsibleError('Unimplemented file type: %s' % ftype)
    
                    except Exception as e:
                        sys.stderr.write("Error while loading config %s: %s" % (cfile, to_native(e)))
    
            # set default if we got here w/o a value
            if value is None:
                if defs[config].get('required', False):
                    if not plugin_type or config not in INTERNAL_DEFS.get(plugin_type, {}):
                        raise AnsibleRequiredOptionError(f"Required config {_get_config_label(plugin_type, plugin_name, config)} not provided.")
                else:
                    origin = 'default'
                    value = self.template_default(defs[config].get('default'), variables, key_name=_get_config_label(plugin_type, plugin_name, config))
    
            try:
                # ensure correct type, can raise exceptions on mismatched types
                value = ensure_type(value, defs[config].get('type'), origin=origin, origin_ftype=origin_ftype)
            except ValueError as ex:
                if origin.startswith('env:') and value == '':
                    # this is empty env var for non string so we can set to default
                    origin = 'default'
                    value = ensure_type(defs[config].get('default'), defs[config].get('type'), origin=origin, origin_ftype=origin_ftype)
                else:
                    raise AnsibleOptionsError(f'Config {_get_config_label(plugin_type, plugin_name, config)} from {origin!r} has an invalid value.') from ex
    
            # deal with restricted values
            if value is not None and 'choices' in defs[config] and defs[config]['choices'] is not None:
                invalid_choices = True  # assume the worst!
                if defs[config].get('type') == 'list':
                    # for a list type, compare all values in type are allowed
                    invalid_choices = not all(choice in defs[config]['choices'] for choice in value)
                else:
                    # these should be only the simple data types (string, int, bool, float, etc) .. ignore dicts for now
                    invalid_choices = value not in defs[config]['choices']
    
                if invalid_choices:
    
                    if isinstance(defs[config]['choices'], Mapping):
                        valid = ', '.join([to_text(k) for k in defs[config]['choices'].keys()])
                    elif isinstance(defs[config]['choices'], str):
                        valid = defs[config]['choices']
                    elif isinstance(defs[config]['choices'], Sequence):
                        valid = ', '.join([to_text(c) for c in defs[config]['choices']])
                    else:
                        valid = defs[config]['choices']
    
                    raise AnsibleOptionsError(f'Invalid value {value!r} for config {_get_config_label(plugin_type, plugin_name, config)}.',
                                              help_text=f'Valid values are: {valid}')
    
            # deal with deprecation of the setting
            if 'deprecated' in defs[config] and origin != 'default':
                self.DEPRECATED.append((config, defs[config].get('deprecated')))
        else:
>           raise AnsibleUndefinedConfigEntry(f'No config definition exists for {_get_config_label(plugin_type, plugin_name, config)}.')
E           ansible.errors.AnsibleUndefinedConfigEntry: No config definition exists for 'db_host' for inventory plugin.

../../../../python/venv/lib/python3.13/site-packages/ansible/config/manager.py:708: AnsibleUndefinedConfigEntry

The above exception was the direct cause of the following exception:

self = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)
query = 'SELECT * FROM hosts', cache_key = None

    def _execute_query(self, query, cache_key=None):
        """Execute a SQL query and return results, with optional caching."""
        if cache_key and self.get_option("cache"):
            cached_data = self._get_cache_data(cache_key)
            if cached_data is not None:
                return cached_data
    
        try:
>           with self._get_connection() as conn:
                 ^^^^^^^^^^^^^^^^^^^^^^

plugins/inventory/postgresql_inventory.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
plugins/inventory/postgresql_inventory.py:153: in _get_connection
    db_host = self.get_option("db_host")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../python/venv/lib/python3.13/site-packages/ansible/plugins/__init__.py:124: in get_option
    self.get_option_and_origin(option, hostvars=hostvars)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)
option = 'db_host', hostvars = None

    def get_option_and_origin(self, option, hostvars=None):
        if option not in self._options:
            try:
                # some plugins don't use set_option(s) and cannot use direct settings, so this populates the local copy for them
                self._options[option], self._origins[option] = C.config.get_config_value_and_origin(option, plugin_type=self.plugin_type,
                                                                                                    plugin_name=self._load_name, variables=hostvars)
            except AnsibleError as e:
                # callers expect key error on missing
>               raise KeyError() from e
E               KeyError

../../../../python/venv/lib/python3.13/site-packages/ansible/plugins/__init__.py:109: KeyError

During handling of the above exception, another exception occurred:

self = <test_postgresql_inventory.TestPostgreSQLInventoryPlugin object at 0x7f2a0a11e8b0>
inventory_plugin = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)
mock_connection = (<MagicMock name='connect' id='139818534821168'>, <MagicMock name='connect().__enter__().cursor().__enter__()' id='139818534821504'>)

    def test_execute_query_without_cache(self, inventory_plugin, mock_connection):
        """Test query execution without caching."""
        mock_conn, mock_cursor = mock_connection
        mock_cursor.fetchall.return_value = [('host1', ['group1'])]
    
        inventory_plugin.set_options({
            'plugin': 'community.postgresql.postgresql_inventory',
            'cache': False
        })
    
>       result = inventory_plugin._execute_query('SELECT * FROM hosts')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/plugins/inventory/test_postgresql_inventory.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)
query = 'SELECT * FROM hosts', cache_key = None

    def _execute_query(self, query, cache_key=None):
        """Execute a SQL query and return results, with optional caching."""
        if cache_key and self.get_option("cache"):
            cached_data = self._get_cache_data(cache_key)
            if cached_data is not None:
                return cached_data
    
        try:
            with self._get_connection() as conn:
                with conn.cursor() as cur:
                    cur.execute(query)
                    result = cur.fetchall()
    
                    if cache_key and self.get_option("cache"):
                        self._set_cache_data(cache_key, result)
    
                    return result
        except Exception as e:
>           raise AnsibleError(f"Database query failed: {e}")
E           ansible.errors.AnsibleError: Database query failed:

plugins/inventory/postgresql_inventory.py:190: AnsibleError
_______ TestPostgreSQLInventoryPlugin.test_process_inventory_row_minimal _______

self = <test_postgresql_inventory.TestPostgreSQLInventoryPlugin object at 0x7f2a0a15f550>
inventory_plugin = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)

    def test_process_inventory_row_minimal(self, inventory_plugin):
        """Test processing a row with minimal required fields."""
        row = ('web-server-1', ['web_servers'])
    
        inventory_plugin._process_inventory_row(row)
    
        assert 'web-server-1' in inventory_plugin.inventory.hosts
        assert 'web_servers' in inventory_plugin.inventory.groups
>       assert 'web-server-1' in inventory_plugin.inventory.groups['web_servers'].hosts
E       AssertionError: assert 'web-server-1' in [web-server-1]
E        +  where [web-server-1] = web_servers.hosts

tests/unit/plugins/inventory/test_postgresql_inventory.py:140: AssertionError
_ TestPostgreSQLInventoryPlugin.test_add_host_to_groups_string_comma_separated _

self = <test_postgresql_inventory.TestPostgreSQLInventoryPlugin object at 0x7f2a0a132750>
inventory_plugin = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)

    def test_add_host_to_groups_string_comma_separated(self, inventory_plugin):
        """Test adding host to groups from comma-separated string."""
        inventory_plugin._add_host_to_groups('host1', 'web,app,db')
    
        assert 'web' in inventory_plugin.inventory.groups
        assert 'app' in inventory_plugin.inventory.groups
        assert 'db' in inventory_plugin.inventory.groups
>       assert 'host1' in inventory_plugin.inventory.groups['web'].hosts
E       AssertionError: assert 'host1' in [host1]
E        +  where [host1] = web.hosts

tests/unit/plugins/inventory/test_postgresql_inventory.py:208: AssertionError
__________ TestPostgreSQLInventoryPlugin.test_full_parse_integration ___________

self = <test_postgresql_inventory.TestPostgreSQLInventoryPlugin object at 0x7f2a0a1cbbd0>
inventory_plugin = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)
mock_connection = (<MagicMock name='connect' id='139818534827552'>, <MagicMock name='connect().__enter__().cursor().__enter__()' id='139818534823520'>)

    def test_full_parse_integration(self, inventory_plugin, mock_connection):
        """Test full parse method integration."""
        mock_conn, mock_cursor = mock_connection
        mock_cursor.fetchall.return_value = [
            ('web1', ['web_servers'], '10.0.0.1', '{"ansible_user": "ubuntu", "zone": "us-east-1"}'),
            ('web2', ['web_servers', 'staging'], '10.0.0.2', 'ansible_user=centos,environment=staging'),
            ('db1', ['db_servers'], '10.0.1.1', ['role=primary', 'replication=true']),
            ('lb1', ['load_balancers'], None, None)
        ]
    
        # Mock config reading
        with patch.object(inventory_plugin, '_read_config_data'):
            inventory_plugin.set_options({
                'plugin': 'community.postgresql.postgresql_inventory',
                'db_host': 'pg.gebz.local',
                'db_name': 'ansible',
                'db_user': 'ansible',
                'db_password': 'ansible',
                'query': 'SELECT name, groups, ansible_host, host_vars FROM inventory'
            })
    
>           inventory_plugin.parse(inventory_plugin.inventory, DataLoader(), '/fake/path.yml')

tests/unit/plugins/inventory/test_postgresql_inventory.py:269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)
inventory = <ansible.inventory.data.InventoryData object at 0x7f2a0a16b5c0>
loader = <ansible.parsing.dataloader.DataLoader object at 0x7f2a0c4e7650>
path = '/fake/path.yml', cache = True

    def parse(self, inventory, loader, path, cache=True):
        super().parse(inventory, loader, path, cache)
        self._read_config_data(path)
    
>       self.set_options(direct=self.config)
                                ^^^^^^^^^^^
E       AttributeError: 'InventoryModule' object has no attribute 'config'

plugins/inventory/postgresql_inventory.py:137: AttributeError
____________ TestPostgreSQLInventoryPlugin.test_parse_missing_query ____________

self = <test_postgresql_inventory.TestPostgreSQLInventoryPlugin object at 0x7f2a0a1cbe50>
inventory_plugin = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)

    def test_parse_missing_query(self, inventory_plugin):
        """Test parse method with missing query option."""
        with patch.object(inventory_plugin, '_read_config_data'):
            inventory_plugin.set_options({
                'plugin': 'community.postgresql.postgresql_inventory'
                # Missing required 'query'
            })
    
            with pytest.raises(AnsibleParserError, match="The 'query' option is required"):
>               inventory_plugin.parse(inventory_plugin.inventory, DataLoader(), '/fake/path.yml')

tests/unit/plugins/inventory/test_postgresql_inventory.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)
inventory = <ansible.inventory.data.InventoryData object at 0x7f2a0a1cbc50>
loader = <ansible.parsing.dataloader.DataLoader object at 0x7f2a0b173690>
path = '/fake/path.yml', cache = True

    def parse(self, inventory, loader, path, cache=True):
        super().parse(inventory, loader, path, cache)
        self._read_config_data(path)
    
>       self.set_options(direct=self.config)
                                ^^^^^^^^^^^
E       AttributeError: 'InventoryModule' object has no attribute 'config'

plugins/inventory/postgresql_inventory.py:137: AttributeError
__________ TestPostgreSQLInventoryPlugin.test_groups_with_whitespace ___________

self = <test_postgresql_inventory.TestPostgreSQLInventoryPlugin object at 0x7f2a0c4fb530>
inventory_plugin = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)

    def test_groups_with_whitespace(self, inventory_plugin):
        """Test groups with leading/trailing whitespace."""
        row = ('host1', ['  web_servers  ', '  db_servers  '], None, None)
    
        inventory_plugin._process_inventory_row(row)
    
        # Groups should be trimmed
>       assert 'web_servers' in inventory_plugin.inventory.groups
E       AssertionError: assert 'web_servers' in {'  db_servers  ':   db_servers  , '  web_servers  ':   web_servers  , 'all': all, 'ungrouped': ungrouped}
E        +  where {'  db_servers  ':   db_servers  , '  web_servers  ':   web_servers  , 'all': all, 'ungrouped': ungrouped} = <ansible.inventory.data.InventoryData object at 0x7f2a0a1cb450>.groups
E        +    where <ansible.inventory.data.InventoryData object at 0x7f2a0a1cb450> = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None).inventory

tests/unit/plugins/inventory/test_postgresql_inventory.py:346: AssertionError
----------------------------- Captured stderr call -----------------------------
[WARNING]: Invalid characters were found in group names but not replaced, use -vvvv to see details
=========================== short test summary info ============================
FAILED tests/unit/plugins/inventory/test_postgresql_inventory.py::TestPostgreSQLInventoryPlugin::test_get_connection_missing_params
FAILED tests/unit/plugins/inventory/test_postgresql_inventory.py::TestPostgreSQLInventoryPlugin::test_execute_query_with_cache
FAILED tests/unit/plugins/inventory/test_postgresql_inventory.py::TestPostgreSQLInventoryPlugin::test_execute_query_without_cache
FAILED tests/unit/plugins/inventory/test_postgresql_inventory.py::TestPostgreSQLInventoryPlugin::test_process_inventory_row_minimal
FAILED tests/unit/plugins/inventory/test_postgresql_inventory.py::TestPostgreSQLInventoryPlugin::test_add_host_to_groups_string_comma_separated
FAILED tests/unit/plugins/inventory/test_postgresql_inventory.py::TestPostgreSQLInventoryPlugin::test_full_parse_integration
FAILED tests/unit/plugins/inventory/test_postgresql_inventory.py::TestPostgreSQLInventoryPlugin::test_parse_missing_query
FAILED tests/unit/plugins/inventory/test_postgresql_inventory.py::TestPostgreSQLInventoryPlugin::test_groups_with_whitespace
========================= 8 failed, 18 passed in 0.25s =========================
