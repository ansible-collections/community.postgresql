============================= test session starts ==============================
platform linux -- Python 3.13.5, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/gebz/projects/ansible/collections/ansible_collections/community.postgresql
plugins: mock-3.15.1
collected 26 items

tests/unit/plugins/inventory/test_postgresql_inventory.py ........F..... [ 53%]
.F.....FF..F                                                             [100%]

=================================== FAILURES ===================================
_______ TestPostgreSQLInventoryPlugin.test_process_inventory_row_minimal _______

self = <test_postgresql_inventory.TestPostgreSQLInventoryPlugin object at 0x7f6643363750>
inventory_plugin = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)

    def test_process_inventory_row_minimal(self, inventory_plugin):
        """Test processing a row with minimal required fields."""
        row = ('web-server-1', ['web_servers'])
    
        inventory_plugin._process_inventory_row(row)
    
        assert 'web-server-1' in inventory_plugin.inventory.hosts
        assert 'web_servers' in inventory_plugin.inventory.groups
>       assert 'web-server-1' in inventory_plugin.inventory.groups['web_servers'].hosts
E       AssertionError: assert 'web-server-1' in [web-server-1]
E        +  where [web-server-1] = web_servers.hosts

tests/unit/plugins/inventory/test_postgresql_inventory.py:150: AssertionError
_ TestPostgreSQLInventoryPlugin.test_add_host_to_groups_string_comma_separated _

self = <test_postgresql_inventory.TestPostgreSQLInventoryPlugin object at 0x7f6643332b10>
inventory_plugin = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)

    def test_add_host_to_groups_string_comma_separated(self, inventory_plugin):
        """Test adding host to groups from comma-separated string."""
        inventory_plugin._add_host_to_groups('host1', 'web,app,db')
    
        assert 'web' in inventory_plugin.inventory.groups
        assert 'app' in inventory_plugin.inventory.groups
        assert 'db' in inventory_plugin.inventory.groups
>       assert 'host1' in inventory_plugin.inventory.groups['web'].hosts
E       AssertionError: assert 'host1' in [host1]
E        +  where [host1] = web.hosts

tests/unit/plugins/inventory/test_postgresql_inventory.py:218: AssertionError
__________ TestPostgreSQLInventoryPlugin.test_full_parse_integration ___________

self = <test_postgresql_inventory.TestPostgreSQLInventoryPlugin object at 0x7f66433cfcd0>
inventory_plugin = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)
mock_connection = (<MagicMock name='connect' id='140077191293184'>, <MagicMock name='connect().__enter__().cursor().__enter__()' id='140077191291840'>)

    def test_full_parse_integration(self, inventory_plugin, mock_connection):
        """Test full parse method integration."""
        mock_conn, mock_cursor = mock_connection
        mock_cursor.fetchall.return_value = [
            ('web1', ['web_servers'], '10.0.0.1', '{"ansible_user": "ubuntu", "zone": "us-east-1"}'),
            ('web2', ['web_servers', 'staging'], '10.0.0.2', 'ansible_user=centos,environment=staging'),
            ('db1', ['db_servers'], '10.0.1.1', ['role=primary', 'replication=true']),
            ('lb1', ['load_balancers'], None, None)
        ]
    
        # Mock config reading
        with patch.object(inventory_plugin, '_read_config_data'):
            inventory_plugin.set_options(direct={
                'plugin': 'community.postgresql.postgresql_inventory',
                'db_host': 'pg.gebz.local',
                'db_name': 'ansible',
                'db_user': 'ansible',
                'db_password': 'ansible',
                'query': 'SELECT name, groups, ansible_host, host_vars FROM inventory'
            })
    
>           inventory_plugin.parse(inventory_plugin.inventory, DataLoader(), '/fake/path.yml')

tests/unit/plugins/inventory/test_postgresql_inventory.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
plugins/inventory/postgresql_inventory.py:135: in parse
    self.set_option("cache", cache_enabled)
../../../../python/venv/lib/python3.13/site-packages/ansible/plugins/__init__.py:134: in set_option
    self._options[option] = C.config.get_config_value(option, plugin_type=self.plugin_type, plugin_name=self._load_name, direct={option: value})
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../python/venv/lib/python3.13/site-packages/ansible/config/manager.py:547: in get_config_value
    value, _drop = self.get_config_value_and_origin(config, cfile=cfile, plugin_type=plugin_type, plugin_name=plugin_name,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ansible.config.manager.ConfigManager object at 0x7f66447d9be0>
config = 'cache', cfile = None, plugin_type = 'inventory', plugin_name = None
keys = None, variables = None, direct = {'cache': True}

    def get_config_value_and_origin(self, config, cfile=None, plugin_type=None, plugin_name=None, keys=None, variables=None, direct=None):
        """ Given a config key figure out the actual value and report on the origin of the settings """
        if cfile is None:
            # use default config
            cfile = self._config_file
    
        if config == 'CONFIG_FILE':
            return cfile, ''
    
        # Note: sources that are lists listed in low to high precedence (last one wins)
        value = None
        origin = None
        origin_ftype = None
    
        defs = self.get_configuration_definitions(plugin_type=plugin_type, name=plugin_name)
        if config in defs:
    
            aliases = defs[config].get('aliases', [])
    
            # direct setting via plugin arguments, can set to None so we bypass rest of processing/defaults
            if direct:
                if config in direct:
                    value = direct[config]
                    origin = 'Direct'
                else:
                    direct_aliases = [direct[alias] for alias in aliases if alias in direct]
                    if direct_aliases:
                        value = direct_aliases[0]
                        origin = 'Direct'
    
            if value is None and variables and defs[config].get('vars'):
                # Use 'variable overrides' if present, highest precedence, but only present when querying running play
                value, origin = self._loop_entries(variables, defs[config]['vars'])
                origin = 'var: %s' % origin
    
            # use playbook keywords if you have em
            if value is None and defs[config].get('keyword') and keys:
                value, origin = self._loop_entries(keys, defs[config]['keyword'])
                origin = 'keyword: %s' % origin
    
            # automap to keywords
            # TODO: deprecate these in favor of explicit keyword above
            if value is None and keys:
                if config in keys:
                    value = keys[config]
                    keyword = config
    
                elif aliases:
                    for alias in aliases:
                        if alias in keys:
                            value = keys[alias]
                            keyword = alias
                            break
    
                if value is not None:
                    origin = 'keyword: %s' % keyword
    
            if value is None and 'cli' in defs[config]:
                # avoid circular import .. until valid
                from ansible import context
                value, origin = self._loop_entries(context.CLIARGS, defs[config]['cli'])
                origin = 'cli: %s' % origin
    
            # env vars are next precedence
            if value is None and defs[config].get('env'):
                value, origin = self._loop_entries(os.environ, defs[config]['env'])
                value = _tags.TrustedAsTemplate().tag(value)
                origin = 'env: %s' % origin
    
            # try config file entries next, if we have one
            if self._parsers.get(cfile, None) is None:
                self._parse_config_file(cfile)
    
            # attempt to read from config file
            if value is None and cfile is not None:
                ftype = get_config_type(cfile)
                if ftype and defs[config].get(ftype):
                    try:
                        for entry in defs[config][ftype]:
                            # load from config
                            if ftype == 'ini':
                                temp_value = self._get_ini_config_value(cfile, entry.get('section', 'defaults'), entry['key'])
                            elif ftype == 'yaml':
                                raise AnsibleError('YAML configuration type has not been implemented yet')
                            else:
                                raise AnsibleError('Invalid configuration file type: %s' % ftype)
    
                            if temp_value is not None:
                                # set value and origin
                                value = temp_value
                                origin = cfile
                                origin_ftype = ftype
                                if 'deprecated' in entry:
                                    if ftype == 'ini':
                                        self.DEPRECATED.append(('[%s]%s' % (entry['section'], entry['key']), entry['deprecated']))
                                    else:
                                        raise AnsibleError('Unimplemented file type: %s' % ftype)
    
                    except Exception as e:
                        sys.stderr.write("Error while loading config %s: %s" % (cfile, to_native(e)))
    
            # set default if we got here w/o a value
            if value is None:
                if defs[config].get('required', False):
                    if not plugin_type or config not in INTERNAL_DEFS.get(plugin_type, {}):
                        raise AnsibleRequiredOptionError(f"Required config {_get_config_label(plugin_type, plugin_name, config)} not provided.")
                else:
                    origin = 'default'
                    value = self.template_default(defs[config].get('default'), variables, key_name=_get_config_label(plugin_type, plugin_name, config))
    
            try:
                # ensure correct type, can raise exceptions on mismatched types
                value = ensure_type(value, defs[config].get('type'), origin=origin, origin_ftype=origin_ftype)
            except ValueError as ex:
                if origin.startswith('env:') and value == '':
                    # this is empty env var for non string so we can set to default
                    origin = 'default'
                    value = ensure_type(defs[config].get('default'), defs[config].get('type'), origin=origin, origin_ftype=origin_ftype)
                else:
                    raise AnsibleOptionsError(f'Config {_get_config_label(plugin_type, plugin_name, config)} from {origin!r} has an invalid value.') from ex
    
            # deal with restricted values
            if value is not None and 'choices' in defs[config] and defs[config]['choices'] is not None:
                invalid_choices = True  # assume the worst!
                if defs[config].get('type') == 'list':
                    # for a list type, compare all values in type are allowed
                    invalid_choices = not all(choice in defs[config]['choices'] for choice in value)
                else:
                    # these should be only the simple data types (string, int, bool, float, etc) .. ignore dicts for now
                    invalid_choices = value not in defs[config]['choices']
    
                if invalid_choices:
    
                    if isinstance(defs[config]['choices'], Mapping):
                        valid = ', '.join([to_text(k) for k in defs[config]['choices'].keys()])
                    elif isinstance(defs[config]['choices'], str):
                        valid = defs[config]['choices']
                    elif isinstance(defs[config]['choices'], Sequence):
                        valid = ', '.join([to_text(c) for c in defs[config]['choices']])
                    else:
                        valid = defs[config]['choices']
    
                    raise AnsibleOptionsError(f'Invalid value {value!r} for config {_get_config_label(plugin_type, plugin_name, config)}.',
                                              help_text=f'Valid values are: {valid}')
    
            # deal with deprecation of the setting
            if 'deprecated' in defs[config] and origin != 'default':
                self.DEPRECATED.append((config, defs[config].get('deprecated')))
        else:
>           raise AnsibleUndefinedConfigEntry(f'No config definition exists for {_get_config_label(plugin_type, plugin_name, config)}.')
E           ansible.errors.AnsibleUndefinedConfigEntry: No config definition exists for 'cache' for inventory plugin.

../../../../python/venv/lib/python3.13/site-packages/ansible/config/manager.py:708: AnsibleUndefinedConfigEntry
____________ TestPostgreSQLInventoryPlugin.test_parse_missing_query ____________

self = <test_postgresql_inventory.TestPostgreSQLInventoryPlugin object at 0x7f66433cff50>
inventory_plugin = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)

    def test_parse_missing_query(self, inventory_plugin):
        """Test parse method with missing query option."""
        with patch.object(inventory_plugin, '_read_config_data'):
            inventory_plugin.set_options(direct={
                'plugin': 'community.postgresql.postgresql_inventory'
                # Missing required 'query'
            })
    
            with pytest.raises(AnsibleParserError, match="The 'query' option is required"):
>               inventory_plugin.parse(inventory_plugin.inventory, DataLoader(), '/fake/path.yml')

tests/unit/plugins/inventory/test_postgresql_inventory.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
plugins/inventory/postgresql_inventory.py:135: in parse
    self.set_option("cache", cache_enabled)
../../../../python/venv/lib/python3.13/site-packages/ansible/plugins/__init__.py:134: in set_option
    self._options[option] = C.config.get_config_value(option, plugin_type=self.plugin_type, plugin_name=self._load_name, direct={option: value})
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../python/venv/lib/python3.13/site-packages/ansible/config/manager.py:547: in get_config_value
    value, _drop = self.get_config_value_and_origin(config, cfile=cfile, plugin_type=plugin_type, plugin_name=plugin_name,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ansible.config.manager.ConfigManager object at 0x7f66447d9be0>
config = 'cache', cfile = None, plugin_type = 'inventory', plugin_name = None
keys = None, variables = None, direct = {'cache': True}

    def get_config_value_and_origin(self, config, cfile=None, plugin_type=None, plugin_name=None, keys=None, variables=None, direct=None):
        """ Given a config key figure out the actual value and report on the origin of the settings """
        if cfile is None:
            # use default config
            cfile = self._config_file
    
        if config == 'CONFIG_FILE':
            return cfile, ''
    
        # Note: sources that are lists listed in low to high precedence (last one wins)
        value = None
        origin = None
        origin_ftype = None
    
        defs = self.get_configuration_definitions(plugin_type=plugin_type, name=plugin_name)
        if config in defs:
    
            aliases = defs[config].get('aliases', [])
    
            # direct setting via plugin arguments, can set to None so we bypass rest of processing/defaults
            if direct:
                if config in direct:
                    value = direct[config]
                    origin = 'Direct'
                else:
                    direct_aliases = [direct[alias] for alias in aliases if alias in direct]
                    if direct_aliases:
                        value = direct_aliases[0]
                        origin = 'Direct'
    
            if value is None and variables and defs[config].get('vars'):
                # Use 'variable overrides' if present, highest precedence, but only present when querying running play
                value, origin = self._loop_entries(variables, defs[config]['vars'])
                origin = 'var: %s' % origin
    
            # use playbook keywords if you have em
            if value is None and defs[config].get('keyword') and keys:
                value, origin = self._loop_entries(keys, defs[config]['keyword'])
                origin = 'keyword: %s' % origin
    
            # automap to keywords
            # TODO: deprecate these in favor of explicit keyword above
            if value is None and keys:
                if config in keys:
                    value = keys[config]
                    keyword = config
    
                elif aliases:
                    for alias in aliases:
                        if alias in keys:
                            value = keys[alias]
                            keyword = alias
                            break
    
                if value is not None:
                    origin = 'keyword: %s' % keyword
    
            if value is None and 'cli' in defs[config]:
                # avoid circular import .. until valid
                from ansible import context
                value, origin = self._loop_entries(context.CLIARGS, defs[config]['cli'])
                origin = 'cli: %s' % origin
    
            # env vars are next precedence
            if value is None and defs[config].get('env'):
                value, origin = self._loop_entries(os.environ, defs[config]['env'])
                value = _tags.TrustedAsTemplate().tag(value)
                origin = 'env: %s' % origin
    
            # try config file entries next, if we have one
            if self._parsers.get(cfile, None) is None:
                self._parse_config_file(cfile)
    
            # attempt to read from config file
            if value is None and cfile is not None:
                ftype = get_config_type(cfile)
                if ftype and defs[config].get(ftype):
                    try:
                        for entry in defs[config][ftype]:
                            # load from config
                            if ftype == 'ini':
                                temp_value = self._get_ini_config_value(cfile, entry.get('section', 'defaults'), entry['key'])
                            elif ftype == 'yaml':
                                raise AnsibleError('YAML configuration type has not been implemented yet')
                            else:
                                raise AnsibleError('Invalid configuration file type: %s' % ftype)
    
                            if temp_value is not None:
                                # set value and origin
                                value = temp_value
                                origin = cfile
                                origin_ftype = ftype
                                if 'deprecated' in entry:
                                    if ftype == 'ini':
                                        self.DEPRECATED.append(('[%s]%s' % (entry['section'], entry['key']), entry['deprecated']))
                                    else:
                                        raise AnsibleError('Unimplemented file type: %s' % ftype)
    
                    except Exception as e:
                        sys.stderr.write("Error while loading config %s: %s" % (cfile, to_native(e)))
    
            # set default if we got here w/o a value
            if value is None:
                if defs[config].get('required', False):
                    if not plugin_type or config not in INTERNAL_DEFS.get(plugin_type, {}):
                        raise AnsibleRequiredOptionError(f"Required config {_get_config_label(plugin_type, plugin_name, config)} not provided.")
                else:
                    origin = 'default'
                    value = self.template_default(defs[config].get('default'), variables, key_name=_get_config_label(plugin_type, plugin_name, config))
    
            try:
                # ensure correct type, can raise exceptions on mismatched types
                value = ensure_type(value, defs[config].get('type'), origin=origin, origin_ftype=origin_ftype)
            except ValueError as ex:
                if origin.startswith('env:') and value == '':
                    # this is empty env var for non string so we can set to default
                    origin = 'default'
                    value = ensure_type(defs[config].get('default'), defs[config].get('type'), origin=origin, origin_ftype=origin_ftype)
                else:
                    raise AnsibleOptionsError(f'Config {_get_config_label(plugin_type, plugin_name, config)} from {origin!r} has an invalid value.') from ex
    
            # deal with restricted values
            if value is not None and 'choices' in defs[config] and defs[config]['choices'] is not None:
                invalid_choices = True  # assume the worst!
                if defs[config].get('type') == 'list':
                    # for a list type, compare all values in type are allowed
                    invalid_choices = not all(choice in defs[config]['choices'] for choice in value)
                else:
                    # these should be only the simple data types (string, int, bool, float, etc) .. ignore dicts for now
                    invalid_choices = value not in defs[config]['choices']
    
                if invalid_choices:
    
                    if isinstance(defs[config]['choices'], Mapping):
                        valid = ', '.join([to_text(k) for k in defs[config]['choices'].keys()])
                    elif isinstance(defs[config]['choices'], str):
                        valid = defs[config]['choices']
                    elif isinstance(defs[config]['choices'], Sequence):
                        valid = ', '.join([to_text(c) for c in defs[config]['choices']])
                    else:
                        valid = defs[config]['choices']
    
                    raise AnsibleOptionsError(f'Invalid value {value!r} for config {_get_config_label(plugin_type, plugin_name, config)}.',
                                              help_text=f'Valid values are: {valid}')
    
            # deal with deprecation of the setting
            if 'deprecated' in defs[config] and origin != 'default':
                self.DEPRECATED.append((config, defs[config].get('deprecated')))
        else:
>           raise AnsibleUndefinedConfigEntry(f'No config definition exists for {_get_config_label(plugin_type, plugin_name, config)}.')
E           ansible.errors.AnsibleUndefinedConfigEntry: No config definition exists for 'cache' for inventory plugin.

../../../../python/venv/lib/python3.13/site-packages/ansible/config/manager.py:708: AnsibleUndefinedConfigEntry
__________ TestPostgreSQLInventoryPlugin.test_groups_with_whitespace ___________

self = <test_postgresql_inventory.TestPostgreSQLInventoryPlugin object at 0x7f6644e33950>
inventory_plugin = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None)

    def test_groups_with_whitespace(self, inventory_plugin):
        """Test groups with leading/trailing whitespace."""
        row = ('host1', ['  web_servers  ', '  db_servers  '], None, None)
    
        inventory_plugin._process_inventory_row(row)
    
        # Groups should be trimmed
>       assert 'web_servers' in inventory_plugin.inventory.groups
E       AssertionError: assert 'web_servers' in {'  db_servers  ':   db_servers  , '  web_servers  ':   web_servers  , 'all': all, 'ungrouped': ungrouped}
E        +  where {'  db_servers  ':   db_servers  , '  web_servers  ':   web_servers  , 'all': all, 'ungrouped': ungrouped} = <ansible.inventory.data.InventoryData object at 0x7f6642bc8a50>.groups
E        +    where <ansible.inventory.data.InventoryData object at 0x7f6642bc8a50> = InventoryModule(plugin_type='inventory', ansible_name=None, load_name=None).inventory

tests/unit/plugins/inventory/test_postgresql_inventory.py:356: AssertionError
----------------------------- Captured stderr call -----------------------------
[WARNING]: Invalid characters were found in group names but not replaced, use -vvvv to see details
=========================== short test summary info ============================
FAILED tests/unit/plugins/inventory/test_postgresql_inventory.py::TestPostgreSQLInventoryPlugin::test_process_inventory_row_minimal
FAILED tests/unit/plugins/inventory/test_postgresql_inventory.py::TestPostgreSQLInventoryPlugin::test_add_host_to_groups_string_comma_separated
FAILED tests/unit/plugins/inventory/test_postgresql_inventory.py::TestPostgreSQLInventoryPlugin::test_full_parse_integration
FAILED tests/unit/plugins/inventory/test_postgresql_inventory.py::TestPostgreSQLInventoryPlugin::test_parse_missing_query
FAILED tests/unit/plugins/inventory/test_postgresql_inventory.py::TestPostgreSQLInventoryPlugin::test_groups_with_whitespace
========================= 5 failed, 21 passed in 0.23s =========================
